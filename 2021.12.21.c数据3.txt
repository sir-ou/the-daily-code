////例题4
//int main()
//{
//    int a=-20;
//    //原码10000000000000000000010100
//    //反码11111111111111111111101011
//    //补码11111111111111111111101100
//    unsigned int b=10;
//    //原码00000000000000000000001010
//    //补码00000000000000000000001010
//    printf("%d\n",a+b);
//    //1111111111111111111111101100
//    //0000000000000000000000001010
//    //补码1111111111111111111111110110    反码11111111111111111111110101   原码10000000000000000000001010   -10
//    return 0;
//    //按照补码进行计算，最后格式化为有符号整数。
//}
////例题5
//int main()
//{
//    unsigned int i;
//    for(i=9;i>=0;i--)
//    {
//        printf("%u\n",i);
//        Sleep(100);
//    }
//    //因为i恒大于零 所以 当 最后一个0输出之后 死循环
//    return 0;
//}
////例题6
//int main()
//{
//    char a[1000];
//    int i;
//    for(i=0;i<1000;i++)
//    {
//        a[i]=-1-i;//char范围是-128~127
//        //错误理解 -1 -2 -3 ··· -128 -129 ··· -1000 没有遇到 \0 所以打印出一个随机值
//        //正确理解 -1 -2 -3 ··· -128 127 126 125 ··· 1 0 -1 -2 ··· 遇到0就结束 所以打印出255
//    }
//    printf("%d",strlen(a));
//    return 0;
//}
////例题7
//unsigned char i=0;//unsi char 范围0~255
//int main()
//{
//        for(i=0;i<=255;i++)
//        {
//            printf("hello word\n");
//            //死循环
//        }
//    return 0;
//}

//标题4 浮点型在内存中的存储
//常见浮点数  3.14159 1E10 浮点数家族包括：float double long double  浮点数表示范围 ：float.h 定义
////例子1
//int main()
//{
//    int n=9;
//    float* pFloat=(float* )&n;
//    printf("n的值为：%d\n",n);//9
//    printf("*pFloat的值为：%f\n",*pFloat);//0.00000000
//
//    *pFloat=9.0;
//    printf("n的值为：%d\n",n);//1091567616
//    printf("*pFloat的值为：%f\n",*pFloat);//9.000000
//    return 0;
//    //说明了整形和浮点型在内存中的存储是不一样的！！！！！！
//}

////根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1)^S*M*2^E
//(-1)^表示符号位，当S=0，V为正数；当S等于1，V为负数
//M表示有效数字，大于等于1，小于2
//2^E表示指数位
//例子
//十进制的5.0，写成二进制是101.0，相当于1.01*2^2，即S=0，M=1.01，E=2。

//IEEE 745规定：对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。
                              //即S（1bit）  E（8bit）  M（23bit）
//IEEE 745规定：对于64位的浮点数，最高的1位是符号位S，接着118位是指数E，剩下的52位为有效数字M。
                              //即S（1bit）  E（11bit）  M（52bit）
//IEEE 745规定：对于有效数字M，由于M是1.xxxxx的格式，存在内存里面是将1.舍去，只存小数位，这样精度更高一位，读取的时候把1.加上去.

//IEEE 745规定：对于指数位E，首先E为一个无符号数。这意味着，如果E为8位，取值范围是0~255。如果E为11位，取值范围为2047。
//但是，我们知道，科学计数法中E可能为负值，所以存入内存是E的真实值必须加上一个中间数，对于8位E，中间数是127，对于11位E，中间数是1023。
//比如，2^10中E为10，所以保存为32位浮点数时，必须存为10+127=137，即10001001.

////写个代码测试一下
//int main()
//{
//    float a=5.5;
//    //101.1
//    //科学计数法（-1）^0*1.011*2^2
//    //S=0 M=1.011 E=2  2+127=129
//    //32位浮点数
//    //0 10000001  0110000000000000000000000000
//    //0100 0000 1011 0000 0000 0000 0000 0000
//    //十六进制0x40b00000
//    return 0;
//}